#!/bin/bash
# Script de gestion VPN - Connexion multi-VPN via openfortivpn
# Configuration dans ~/.vpn/vpns.conf (format INI)
# Usage: vpn [connect|disconnect|status|list|help]

set -o pipefail

# === Chemins ===
VPN_DIR="$HOME/.vpn"
VPN_CONF="$VPN_DIR/vpns.conf"
CONFIG_DIR="$VPN_DIR/configs"
PASSWORD_FILE="$VPN_DIR/passwords.conf"
LOG_DIR="$VPN_DIR/logs"
SESSION_DIR="$VPN_DIR/sessions"

mkdir -p "$LOG_DIR" "$SESSION_DIR"

# === Couleurs ===
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

# === Timeouts par d√©faut par mode d'auth ===
declare -A DEFAULT_TIMEOUTS
DEFAULT_TIMEOUTS[password]=20
DEFAULT_TIMEOUTS[2fa]=30
DEFAULT_TIMEOUTS[saml]=60

# ============================================================
#  Parseur INI g√©n√©rique (pur bash, aucune d√©pendance)
# ============================================================

# Liste ordonn√©e des IDs de VPN (ordre du fichier)
VPN_IDS=()

# Tableaux associatifs : VPN_PROP[id.cl√©] = valeur
declare -A VPN_PROP

# Charger la configuration INI
load_config() {
    if [ ! -f "$VPN_CONF" ]; then
        echo -e "${RED}‚ùå Fichier de configuration introuvable: $VPN_CONF${NC}" >&2
        exit 1
    fi

    local current_section=""
    while IFS= read -r line || [ -n "$line" ]; do
        # Ignorer lignes vides et commentaires
        [[ -z "$line" || "$line" =~ ^[[:space:]]*# ]] && continue

        # D√©tecter une section [nom]
        if [[ "$line" =~ ^\[([a-zA-Z0-9_-]+)\]$ ]]; then
            current_section="${BASH_REMATCH[1]}"
            VPN_IDS+=("$current_section")
            continue
        fi

        # Lire cl√© = valeur
        if [[ -n "$current_section" && "$line" =~ ^[[:space:]]*([a-zA-Z0-9_]+)[[:space:]]*=[[:space:]]*(.+)$ ]]; then
            local key="${BASH_REMATCH[1]}"
            local value="${BASH_REMATCH[2]}"
            # Supprimer les espaces en fin de valeur
            value="${value%"${value##*[![:space:]]}"}"
            VPN_PROP["${current_section}.${key}"]="$value"
        fi
    done < "$VPN_CONF"

    if [ ${#VPN_IDS[@]} -eq 0 ]; then
        echo -e "${RED}‚ùå Aucun VPN d√©fini dans $VPN_CONF${NC}" >&2
        exit 1
    fi
}

# Acc√©der √† une propri√©t√© d'un VPN (avec valeur par d√©faut optionnelle)
vpn_get() {
    local id="$1" key="$2" default="${3:-}"
    local value="${VPN_PROP["${id}.${key}"]}"
    echo "${value:-$default}"
}

# Nombre de VPNs configur√©s
vpn_count() {
    echo "${#VPN_IDS[@]}"
}

# ID du VPN √† l'index donn√© (1-based)
vpn_id_at() {
    local index=$(( $1 - 1 ))
    echo "${VPN_IDS[$index]}"
}

# Index (1-based) d'un VPN par son id, retourne "" si non trouv√©
vpn_index_of() {
    local target="$1"
    for i in "${!VPN_IDS[@]}"; do
        if [ "${VPN_IDS[$i]}" = "$target" ]; then
            echo $(( i + 1 ))
            return
        fi
    done
}

# ============================================================
#  Fonctions utilitaires
# ============================================================

log() {
    echo -e "${2}$1${NC}"
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" >> "$LOG_DIR/vpn.log"
}

get_password() {
    local vpn_key="$1"
    if [ -f "$PASSWORD_FILE" ]; then
        grep "^${vpn_key}=" "$PASSWORD_FILE" 2>/dev/null | cut -d'=' -f2-
    fi
}

open_browser() {
    local url="$1"
    
    # Essayer diff√©rentes commandes pour ouvrir le navigateur
    # xdg-open est le standard sur Linux (fonctionne avec GNOME, KDE, XFCE, etc.)
    if command -v xdg-open &> /dev/null; then
        xdg-open "$url" &> /dev/null &
        return 0
    elif command -v gnome-open &> /dev/null; then
        gnome-open "$url" &> /dev/null &
        return 0
    elif command -v kde-open &> /dev/null; then
        kde-open "$url" &> /dev/null &
        return 0
    elif command -v firefox &> /dev/null; then
        firefox "$url" &> /dev/null &
        return 0
    elif command -v google-chrome &> /dev/null; then
        google-chrome "$url" &> /dev/null &
        return 0
    elif command -v chromium &> /dev/null; then
        chromium "$url" &> /dev/null &
        return 0
    else
        return 1
    fi
}

# ============================================================
#  Gestion de session / statut
# ============================================================

is_vpn_connected() {
    local vpn_id="$1"
    local session_file="$SESSION_DIR/.session_${vpn_id}"

    if [ ! -f "$session_file" ]; then
        return 1
    fi

    local pid=$(cat "$session_file" 2>/dev/null)
    if [ -n "$pid" ] && [ -d "/proc/$pid" ]; then
        return 0
    fi

    rm -f "$session_file"
    return 1
}

get_connected_vpns() {
    local connected=0
    for session_file in "$SESSION_DIR"/.session_*; do
        [ -f "$session_file" ] || continue
        local vpn_id=$(basename "$session_file" | sed 's/^.session_//')
        local pid=$(cat "$session_file" 2>/dev/null)

        if [ -n "$pid" ] && [ -d "/proc/$pid" ]; then
            local display_name=$(vpn_get "$vpn_id" "name" "$vpn_id")

            # Chercher une interface ppp active
            local ppp_if=$(ip -o link show type ppp 2>/dev/null | awk -F': ' '{print $2}' | sed -n "$((connected+1))p")
            local ip=""
            if [ -n "$ppp_if" ] && ip a show "$ppp_if" &>/dev/null; then
                ip=$(ip a show "$ppp_if" | grep "inet " | awk '{print $2}' | cut -d'/' -f1)
            fi

            if [ -n "$ip" ]; then
                log "‚úÖ $display_name (PID: $pid, IP: $ip)" "$GREEN"
            else
                log "‚úÖ $display_name (PID: $pid)" "$GREEN"
            fi
            connected=$((connected + 1))
        else
            rm -f "$session_file"
        fi
    done

    return $connected
}

check_untracked_vpns() {
    # R√©cup√©rer les PIDs track√©s
    local tracked_pids=()
    for session_file in "$SESSION_DIR"/.session_*; do
        [ -f "$session_file" ] || continue
        local pid=$(cat "$session_file" 2>/dev/null)
        [ -n "$pid" ] && tracked_pids+=("$pid")
    done

    # Chercher les processus openfortivpn non track√©s
    local untracked=0
    while IFS= read -r line; do
        local pid=$(echo "$line" | awk '{print $2}')
        
        # V√©rifier si ce PID est track√©
        local is_tracked=false
        for tracked in "${tracked_pids[@]}"; do
            if [ "$tracked" = "$pid" ]; then
                is_tracked=true
                break
            fi
        done
        
        if [ "$is_tracked" = false ]; then
            # R√©cup√©rer des infos sur ce processus
            local cmd=$(ps -p "$pid" -o args= 2>/dev/null)
            local ppp_if=$(ip -o link show type ppp 2>/dev/null | awk -F': ' '{print $2}' | tail -n 1)
            local ip=""
            if [ -n "$ppp_if" ] && ip a show "$ppp_if" &>/dev/null; then
                ip=$(ip a show "$ppp_if" | grep "inet " | awk '{print $2}' | cut -d'/' -f1)
            fi
            
            if [ -n "$ip" ]; then
                log "‚ö†Ô∏è  VPN non track√© (PID: $pid, IP: $ip)" "$YELLOW"
            else
                log "‚ö†Ô∏è  VPN non track√© (PID: $pid)" "$YELLOW"
            fi
            echo "   Commande: $cmd" | head -c 80
            echo ""
            untracked=$((untracked + 1))
        fi
    done < <(ps aux | grep -E "[o]penfortivpn")
    
    return $untracked
}

check_status() {
    local connected=0
    local has_sessions=false

    for session_file in "$SESSION_DIR"/.session_*; do
        [ -f "$session_file" ] || continue
        has_sessions=true
        break
    done

    if [ "$has_sessions" = true ]; then
        get_connected_vpns
        connected=$?
    fi

    # V√©rifier les VPNs non track√©s
    check_untracked_vpns
    local untracked=$?

    if [ $connected -eq 0 ] && [ $untracked -eq 0 ]; then
        log "‚ùå Aucune connexion VPN active" "$RED"
        return 1
    fi

    if [ $untracked -gt 0 ]; then
        echo ""
        echo -e "${YELLOW}üí° Astuce: Utilisez 'vpn disconnect <pid>' pour d√©connecter un VPN non track√©${NC}"
    fi

    return 0
}

# ============================================================
#  D√©connexion
# ============================================================

disconnect_one() {
    local vpn_id="$1"
    
    # Si c'est un PID (nombre uniquement), d√©connexion directe
    if [[ "$vpn_id" =~ ^[0-9]+$ ]]; then
        local pid="$vpn_id"
        if [ ! -d "/proc/$pid" ]; then
            log "‚ùå Aucun processus avec le PID $pid" "$RED"
            return 1
        fi
        
        # V√©rifier que c'est bien un processus openfortivpn
        if ! ps -p "$pid" -o comm= 2>/dev/null | grep -q "openfortivpn"; then
            log "‚ùå Le PID $pid n'est pas un processus openfortivpn" "$RED"
            return 1
        fi
        
        log "üîå D√©connexion du processus (PID: $pid)..." "$YELLOW"
        sudo kill -INT "$pid" 2>/dev/null
        sleep 2
        if [ -d "/proc/$pid" ]; then
            sudo kill -9 "$pid" 2>/dev/null
            sleep 1
        fi
        
        # Nettoyer toute session orpheline qui pourrait pointer vers ce PID
        for session_file in "$SESSION_DIR"/.session_*; do
            [ -f "$session_file" ] || continue
            local session_pid=$(cat "$session_file" 2>/dev/null)
            if [ "$session_pid" = "$pid" ]; then
                rm -f "$session_file"
            fi
        done
        
        log "‚úÖ Processus d√©connect√©" "$GREEN"
        return 0
    fi
    
    # Sinon, c'est un ID de VPN normal
    local session_file="$SESSION_DIR/.session_${vpn_id}"

    if [ ! -f "$session_file" ]; then
        log "‚ùå $vpn_id n'est pas connect√©" "$RED"
        return 1
    fi

    local pid=$(cat "$session_file" 2>/dev/null)
    if [ -n "$pid" ] && [ -d "/proc/$pid" ]; then
        log "üîå D√©connexion de $vpn_id (PID: $pid)..." "$YELLOW"
        sudo kill -INT "$pid" 2>/dev/null
        sleep 2
        if [ -d "/proc/$pid" ]; then
            sudo kill -9 "$pid" 2>/dev/null
            sleep 1
        fi
    fi

    rm -f "$session_file"
    log "‚úÖ $vpn_id d√©connect√©" "$GREEN"
}

disconnect() {
    local target="$1"

    local connected_vpns=()
    for session_file in "$SESSION_DIR"/.session_*; do
        [ -f "$session_file" ] || continue
        local vpn_id=$(basename "$session_file" | sed 's/^.session_//')
        local pid=$(cat "$session_file" 2>/dev/null)
        if [ -n "$pid" ] && [ -d "/proc/$pid" ]; then
            connected_vpns+=("$vpn_id")
        else
            rm -f "$session_file"
        fi
    done

    # Si un argument est fourni (ID, num√©ro, ou PID)
    if [ -n "$target" ]; then
        # V√©rifier si c'est "all" pour tout d√©connecter
        if [[ "$target" = "all" || "$target" = "a" ]]; then
            for vpn_id in "${connected_vpns[@]}"; do
                disconnect_one "$vpn_id"
            done
            
            # Aussi d√©connecter tous les VPNs non track√©s
            while IFS= read -r line; do
                local pid=$(echo "$line" | awk '{print $2}')
                disconnect_one "$pid"
            done < <(ps aux | grep -E "[o]penfortivpn")
            
            return
        fi
        
        # Si c'est un nombre, v√©rifier d'abord si c'est un PID valide
        if [[ "$target" =~ ^[0-9]+$ ]]; then
            # V√©rifier si c'est un PID de processus openfortivpn
            if [ -d "/proc/$target" ] && ps -p "$target" -o comm= 2>/dev/null | grep -q "openfortivpn"; then
                # C'est un PID valide, d√©connecter directement
                disconnect_one "$target"
                return
            fi
            
            # Sinon, c'est peut-√™tre un index de position
            if [ "$target" -ge 1 ] && [ "$target" -le ${#connected_vpns[@]} ]; then
                disconnect_one "${connected_vpns[$((target - 1))]}"
                return
            else
                # Aucune des deux interpr√©tations ne fonctionne
                log "‚ùå '$target' n'est ni un PID valide ni un index valide (VPNs track√©s: ${#connected_vpns[@]})" "$RED"
                return 1
            fi
        fi
        
        # Sinon, c'est un ID de VPN
        # V√©rifier que ce VPN est bien connect√©
        local found=false
        for vpn_id in "${connected_vpns[@]}"; do
            if [ "$vpn_id" = "$target" ]; then
                found=true
                break
            fi
        done
        
        if [ "$found" = true ]; then
            disconnect_one "$target"
            return
        else
            log "‚ùå VPN '$target' n'est pas connect√©" "$RED"
            return 1
        fi
    fi

    # Mode interactif : v√©rifier s'il y a des VPNs connect√©s
    if [ ${#connected_vpns[@]} -eq 0 ]; then
        log "‚ùå Aucune connexion track√©e active" "$RED"
        
        # V√©rifier s'il y a des VPNs non track√©s
        if ps aux | grep -E "[o]penfortivpn" &>/dev/null; then
            echo ""
            log "‚ö†Ô∏è  Il semble y avoir des VPNs non track√©s actifs" "$YELLOW"
            log "üí° Utilisez 'vpn status' pour les voir et 'vpn disconnect <pid>' pour les d√©connecter" "$BLUE"
        fi
        return 1
    fi

    # Mode interactif : si un seul VPN connect√©, le d√©connecter directement
    if [ ${#connected_vpns[@]} -eq 1 ]; then
        disconnect_one "${connected_vpns[0]}"
        return
    fi

    # Mode interactif : plusieurs VPNs connect√©s
    echo -e "${BLUE}VPNs actuellement connect√©s :${NC}"
    local idx=1
    for vpn_id in "${connected_vpns[@]}"; do
        local display_name=$(vpn_get "$vpn_id" "name" "$vpn_id")
        echo "  $idx) $display_name"
        idx=$((idx + 1))
    done
    echo "  a) Tout d√©connecter"
    echo ""
    read -p "Quel VPN d√©connecter ? " dc_choice

    if [[ "$dc_choice" = "a" || "$dc_choice" = "A" ]]; then
        for vpn_id in "${connected_vpns[@]}"; do
            disconnect_one "$vpn_id"
        done
    elif [[ "$dc_choice" =~ ^[0-9]+$ ]] && [ "$dc_choice" -ge 1 ] && [ "$dc_choice" -le ${#connected_vpns[@]} ]; then
        disconnect_one "${connected_vpns[$((dc_choice - 1))]}"
    else
        log "‚ùå Choix invalide" "$RED"
    fi
}

# ============================================================
#  Liste
# ============================================================

list_vpns() {
    echo -e "${BLUE}VPNs disponibles:${NC}"
    local count=$(vpn_count)
    for i in $(seq 1 "$count"); do
        local vpn_id=$(vpn_id_at "$i")
        local display_name=$(vpn_get "$vpn_id" "name" "$vpn_id")
        if is_vpn_connected "$vpn_id"; then
            echo -e "  $i) ${GREEN}‚óè $display_name${NC}"
        else
            echo "  $i) $display_name"
        fi
    done
}

# ============================================================
#  Connexion
# ============================================================

connect() {
    local count=$(vpn_count)

    # Choisir le VPN
    if [ -z "$1" ]; then
        echo ""
        list_vpns
        echo ""
        read -p "Choisissez un VPN (1-$count): " vpn_choice
    else
        vpn_choice="$1"
    fi

    # Valider le choix
    if ! [[ "$vpn_choice" =~ ^[0-9]+$ ]] || [ "$vpn_choice" -lt 1 ] || [ "$vpn_choice" -gt "$count" ]; then
        log "‚ùå Choix invalide (1-$count)" "$RED"
        return 1
    fi

    local vpn_id=$(vpn_id_at "$vpn_choice")
    local display_name=$(vpn_get "$vpn_id" "name" "$vpn_id")
    local auth=$(vpn_get "$vpn_id" "auth" "password")
    local config_file=$(vpn_get "$vpn_id" "config")
    local password_key=$(vpn_get "$vpn_id" "password_key")
    local timeout=$(vpn_get "$vpn_id" "timeout" "${DEFAULT_TIMEOUTS[$auth]:-20}")

    # V√©rifier si d√©j√† connect√©
    if is_vpn_connected "$vpn_id"; then
        log "‚ö†Ô∏è  $display_name est d√©j√† connect√©" "$YELLOW"
        read -p "Reconnecter ? (o/N) " -n 1 -r
        echo
        if [[ $REPLY =~ ^[Oo]$ ]]; then
            disconnect_one "$vpn_id"
            sleep 2
        else
            return 1
        fi
    fi

    # M√©moriser les interfaces ppp existantes avant connexion
    local ppp_before=$(ip -o link show type ppp 2>/dev/null | awk -F': ' '{print $2}' | sort)
    local vpn_log="$LOG_DIR/${vpn_id}.log"

    # === Branche SAML ===
    if [ "$auth" = "saml" ]; then
        local saml_host=$(vpn_get "$vpn_id" "saml_host")
        local saml_cert=$(vpn_get "$vpn_id" "saml_cert")

        if [ -z "$saml_host" ]; then
            log "‚ùå saml_host manquant dans la config pour $vpn_id" "$RED"
            return 1
        fi

        if ! command -v openfortivpn &> /dev/null; then
            log "‚ùå openfortivpn n'est pas install√©" "$RED"
            return 1
        fi

        log "üîê Ce VPN utilise l'authentification SSO (SAML)" "$YELLOW"
        echo ""

        local saml_cmd="openfortivpn $saml_host --saml-login"
        [ -n "$saml_cert" ] && saml_cmd="$saml_cmd --trusted-cert $saml_cert"

        sudo -b bash -c "$saml_cmd > \"$vpn_log\" 2>&1"
        sleep 1
        local vpn_pid=$(pgrep -n -f "openfortivpn.*$saml_host" 2>/dev/null)

        # Attendre l'URL SAML (max 10s)
        echo -n "D√©marrage"
        local url_found=false
        for i in {1..10}; do
            if [ -f "$vpn_log" ]; then
                local auth_url=$(grep -oP "Authenticate at '\K[^']+" "$vpn_log" 2>/dev/null)
                if [ -n "$auth_url" ]; then
                    url_found=true
                    echo ""
                    echo ""
                    echo -e "${BLUE}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${NC}"
                    echo -e "${YELLOW}üåê Authentification SSO requise${NC}"
                    echo ""
                    echo -e "  ${GREEN}$auth_url${NC}"
                    echo ""
                    echo -e "${BLUE}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${NC}"
                    echo ""
                    
                    # Essayer d'ouvrir automatiquement le navigateur
                    if open_browser "$auth_url"; then
                        echo -e "${GREEN}‚úÖ Navigateur ouvert automatiquement${NC}"
                    else
                        echo -e "${YELLOW}‚ö†Ô∏è  Impossible d'ouvrir le navigateur automatiquement${NC}"
                        echo -e "${YELLOW}   Veuillez ouvrir l'URL ci-dessus manuellement${NC}"
                    fi
                    echo ""
                    
                    break
                fi
            fi
            echo -n "."
            sleep 1
        done

        if [ "$url_found" = false ]; then
            echo ""
            log "‚ùå Impossible de r√©cup√©rer l'URL SAML" "$RED"
            log "üìù V√©rifiez les logs: tail -f $vpn_log" "$YELLOW"
            [ -n "$vpn_pid" ] && sudo kill -INT "$vpn_pid" 2>/dev/null
            return 1
        fi

        echo -e "${YELLOW}En attente de l'authentification dans le navigateur...${NC}"
        _wait_for_connection "$vpn_id" "$vpn_pid" "$ppp_before" "$vpn_log" "$timeout"
        return $?
    fi

    # === Branches password / 2fa (n√©cessitent un fichier de config) ===
    if [ -z "$config_file" ]; then
        log "‚ùå config manquant dans la config pour $vpn_id" "$RED"
        return 1
    fi

    local config_path="$CONFIG_DIR/$config_file"
    if [ ! -f "$config_path" ]; then
        log "‚ùå Configuration introuvable: $config_path" "$RED"
        return 1
    fi

    local temp_config="/tmp/vpn_${vpn_id}_$$.conf"
    cp "$config_path" "$temp_config"

    # Charger le mot de passe
    if [ -n "$password_key" ]; then
        local password=$(get_password "$password_key")
        if [ -n "$password" ]; then
            echo "password = $password" >> "$temp_config"
            log "üîê Mot de passe charg√© depuis $PASSWORD_FILE" "$BLUE"
        else
            log "‚ö†Ô∏è  Pas de mot de passe dans $PASSWORD_FILE pour $password_key" "$YELLOW"
            log "üí° Le mot de passe sera demand√© interactivement" "$BLUE"
        fi
    fi

    log "üöÄ Connexion √† $display_name..." "$BLUE"

    if [ "$auth" = "2fa" ]; then
        # === Mode 2FA : prompt OTP puis background ===
        log "üîê Ce VPN n√©cessite un code FortiToken" "$YELLOW"
        echo ""
        read -p "$(echo -e "${BLUE}Code FortiToken : ${NC}")" otp_code

        if [ -z "$otp_code" ]; then
            log "‚ùå Aucun code FortiToken saisi" "$RED"
            rm -f "$temp_config"
            return 1
        fi

        sudo -b openfortivpn -c "$temp_config" --otp="$otp_code" > "$vpn_log" 2>&1
        sleep 1
        local vpn_pid=$(pgrep -n -f "openfortivpn.*$(basename "$temp_config")" 2>/dev/null)
    else
        # === Mode password : background direct ===
        sudo -b openfortivpn -c "$temp_config" > "$vpn_log" 2>&1
        sleep 1
        local vpn_pid=$(pgrep -n -f "openfortivpn.*$(basename "$temp_config")" 2>/dev/null)
    fi

    echo -n "Connexion en cours"
    _wait_for_connection "$vpn_id" "$vpn_pid" "$ppp_before" "$vpn_log" "$timeout" "$temp_config"
    return $?
}

# ============================================================
#  Attente de connexion (fonction commune aux 3 modes)
# ============================================================

_wait_for_connection() {
    local vpn_id="$1"
    local vpn_pid="$2"
    local ppp_before="$3"
    local vpn_log="$4"
    local timeout="${5:-20}"
    local temp_config="$6"  # optionnel, √† nettoyer
    local display_name=$(vpn_get "$vpn_id" "name" "$vpn_id")

    for i in $(seq 1 "$timeout"); do
        local ppp_after=$(ip -o link show type ppp 2>/dev/null | awk -F': ' '{print $2}' | sort)
        local new_ppp=$(comm -13 <(echo "$ppp_before") <(echo "$ppp_after") | head -1)

        if [ -n "$new_ppp" ]; then
            local ip=$(ip a show "$new_ppp" | grep "inet " | awk '{print $2}' | cut -d'/' -f1)

            echo "$vpn_pid" > "$SESSION_DIR/.session_${vpn_id}"
            [ -n "$temp_config" ] && rm -f "$temp_config"

            echo ""
            log "‚úÖ Connect√© √† $display_name (IP: $ip, interface: $new_ppp)" "$GREEN"
            echo ""
            echo -e "${BLUE}Routes VPN actives:${NC}"
            ip route show | grep "$new_ppp" | head -5
            echo ""
            log "üìù Logs: tail -f $vpn_log" "$BLUE"
            return 0
        fi

        # V√©rifier si le processus a crash√©
        if [ -n "$vpn_pid" ] && ! [ -d "/proc/$vpn_pid" ]; then
            echo ""
            log "‚ùå Le processus openfortivpn s'est arr√™t√©" "$RED"
            log "üìù V√©rifiez les logs: cat $vpn_log" "$YELLOW"
            [ -n "$temp_config" ] && rm -f "$temp_config"
            return 1
        fi

        echo -n "."
        sleep 1
    done

    echo ""
    log "‚ùå Timeout: connexion non √©tablie apr√®s ${timeout}s" "$RED"
    log "üìù V√©rifiez les logs: tail -f $vpn_log" "$YELLOW"
    [ -n "$vpn_pid" ] && sudo kill -INT "$vpn_pid" 2>/dev/null
    [ -n "$temp_config" ] && rm -f "$temp_config"
    return 1
}

# ============================================================
#  Menu interactif
# ============================================================

show_menu() {
    local count=$(vpn_count)
    echo ""
    echo -e "${BLUE}=== Gestionnaire VPN ===${NC}"
    echo ""
    check_status
    echo ""
    list_vpns
    echo ""
    echo "  c) Se connecter"
    echo "  d) Se d√©connecter"
    echo "  s) Statut"
    echo "  q) Quitter"
    echo ""
    read -p "Votre choix: " choice

    case $choice in
        c|C) connect ;;
        d|D) disconnect ;;
        s|S) check_status ;;
        q|Q) exit 0 ;;
        *)
            if [[ "$choice" =~ ^[0-9]+$ ]] && [ "$choice" -ge 1 ] && [ "$choice" -le "$count" ]; then
                connect "$choice"
            else
                log "‚ùå Choix invalide" "$RED"
            fi
            ;;
    esac
}

# ============================================================
#  Point d'entr√©e
# ============================================================

# Charger la configuration au d√©marrage
load_config

case "${1:-menu}" in
    connect|c)
        connect "$2"
        ;;
    disconnect|d|stop)
        disconnect "$2"
        ;;
    status|s)
        check_status
        ;;
    list|l)
        list_vpns
        ;;
    menu|m|"")
        while true; do
            show_menu
        done
        ;;
    help|h|-h|--help)
        echo "Usage: vpn [commande] [options]"
        echo ""
        echo "Commandes:"
        echo "  connect [1-$(vpn_count)]           Se connecter √† un VPN (cumulable)"
        echo "  disconnect [id|num√©ro|pid|all]  Se d√©connecter d'un VPN sp√©cifique"
        echo "                                   - Sans argument : menu interactif"
        echo "                                   - ID du VPN : ex. 'koesio-sso'"
        echo "                                   - Num√©ro : ex. '1' (premier connect√©)"
        echo "                                   - PID : ex. '322169' (VPN non track√©)"
        echo "                                   - 'all' : tout d√©connecter"
        echo "  status                          Afficher le statut de tous les VPNs"
        echo "                                   (track√©s et non track√©s)"
        echo "  list                            Lister les VPNs disponibles"
        echo "  menu                            Menu interactif (par d√©faut)"
        echo "  help                            Afficher cette aide"
        echo ""
        echo "Multi-VPN:"
        echo "  Les VPNs routant vers des r√©seaux diff√©rents peuvent"
        echo "  √™tre lanc√©s simultan√©ment (ex: KORE + SSO)."
        echo ""
        echo "Configuration:"
        echo "  $VPN_CONF"
        echo ""
        echo "Exemples:"
        echo "  vpn                        # Menu interactif"
        echo "  vpn connect 1              # Se connecter au premier VPN"
        echo "  vpn status                 # Voir tous les VPNs (track√©s et non track√©s)"
        echo "  vpn disconnect             # D√©connexion interactive"
        echo "  vpn disconnect koesio-sso  # D√©connecter un VPN par ID"
        echo "  vpn disconnect 2           # D√©connecter le 2e VPN connect√©"
        echo "  vpn disconnect 322169      # D√©connecter par PID (VPN non track√©)"
        echo "  vpn disconnect all         # Tout d√©connecter"
        ;;
    *)
        log "‚ùå Commande inconnue: $1" "$RED"
        echo "Utilisez 'vpn help' pour l'aide"
        ;;
esac
